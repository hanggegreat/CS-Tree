### 复制

在Redis中，可以通过执行`SLAVEOF`命令或者设置`slaveof`选项，让一个服务器（slave）去复制另一个服务器（master）。

Redis的复制功能分为`同步(psync)`和`命令传播`两个操作

- 同步操作用于将从服务器的数据库更新至主服务器当前所处的数据看状态。
- 命令传播用于在主服务器数据库状态被修改，导致主从数据库状态不一致时，让主从服务器数据库重回到一致状态。

#### 同步

同步分为完整重同步和部分重同步两种模式

##### 完整重同步

用于处理初次复制，执行步骤：

1. 从服务器向主服务器发送`PSYNC`命令。
2. 主服务器执行`BGSAVE`命令，在后台生成`RDB`文件，并使用一个缓冲区记录之后执行的命令。
3. 主服务器生成`RDB`文件后，向从服务器发送`RDB`文件，从服务器载入`RDB`文件。
4. 主服务器将缓冲区中的命令发送给从服务器，从服务器执行后，将数据库更新至和主服务器同步的状态。

##### 部分重同步

用于处理断线后重复制。当从服务器重新连接上主服务器时，如果条件允许，主服务器会将从服务器断线期间执行的命令发送给从服务器，从服务器数据库执行命令完毕后即可恢复至与主服务器同步状态。

- 构成部分重同步的三部分

  - 主从服务器的复制偏移量

    - 主服务器每次向从服务器发送N个字节的数据，就将自己的复制偏移量加N。
    - 从服务器每次收到主服务器发来的N个字节的数据，就将自己的复制偏移量加N。

  - 主服务器的复制积压缓冲区

    - 复制积压缓冲区是一个固定长度的FIFO队列，默认大小1MB。

    - 当主服务器向从服务器进行命令传播时，还会将命令写入复制积压缓冲区。复制积压缓冲区中保存着最近传播的命令，并且还维护了每个字节的复制偏移量。

      ![image-20190729152939908](assets/image-20190729152939908.png)

    - 当从服务器重新连接上主服务器时，会发送`PSYNC`命令，将自己的复制偏移量`offset`发送给主服务器，主服务器会根据复制偏移量决定对从服务器执行完整重同步还是部分重同步：

      - 如果偏移量为`offset + 1`的数据在队列中，则执行部分重同步。
      - 如果偏移量为`offset + 1`的数据不在队列中，则执行完整重同步。

  - 服务器的运行ID

    - 每个Redis服务器都会有一个运行ID。
    - 从服务器对主服务器初次复制时，主服务器会将自己的运行ID传送至从服务器，服务器将主服务器的运行ID保存下来。
    - 当从服务器断线后重新连接上主服务器时，会向主服务器发送之前保存的主服务器运行ID
      - 如果发送的运行ID与主服务器的运行ID一致，则主服务器尝试执行部分重同步。
      - 如果发送的运行ID与主服务器的运行ID不一致，则主服务器执行完全重同步。

#### 复制的实现

  - 设置主服务器的地址和端口

     - 从服务器向主服务器发送`SLAVEOF <master_ip> <master_port>`命令。
     - 从服务器保存主服务器的地址和端口信息：

       ``` c
       struct redisServer {
         char *masterhost;
         char *masterport;
       }
       ```

     - 主服务器向发送`SLAVEOF`命令的客户端返回`OK`，之后开始复制。

  - 建立套接字连接

     - 从服务器创建连向主服务器的套接字连接。
     - 从服务器为这个套接字关联一个专门用于复制的文件时间处理器。
     - 主服务器为这个套接字创建相应的客户端状态，将从服务器看做客户端。

  - 从服务器发送`PING`命令

     - 如果主服务器返回了`PONG`，那么连接正常，继续下一个步骤。
     - 如果读取`PING`命令回复超时，或者主服务器返回了一个错误，则断开并重连主服务器。

  - 身份验证

  - 向主服务器发送监听端口信息

  - 同步

  - 命令传播

     - 从服务器默认会以每秒一次的频率向主服务器发送命令：`REPLCONF ACK <replication_offset>`，主要有三个作用：
       1. 检测主从服务器的连接状态
       2. 辅助实现`min-slaves`配置选项
       3. 检测命令丢失（补发网络故障导致的缺失数据）



### Sentinel

Sentinel是Redis高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统，可以监视任意多个主服务器，以及它们所属的从服务器。在所监视的主服务器下线后自动将其属下某个从服务器升级为主服务器。

在Sentinel启动时，服务器会初始化一个`sentinelState`结构，保存了所有和Sentinel功能有关的状态

``` c
struct sentinelState {
  // 当前纪元，用于故障转移
  uint64_t current_epoch;
  // 所有监视的主服务器，键时主服务器名称，值时一个指向sentinelRedisInstance结构的指针
  dict *masters;
  // ...
} sentinelState;
```

`sentinelRedisInstance`结构则用于保存监视的Redis服务器实例（master、slave、其他sentinel）信息

``` c
struct sentinelRedisInstance {
  // 实例状态
  int flag;
  // ip:port
  char *name;
  char *runid;
  // 配置纪元，用于故障转移
  uint64_t current_epoch;
  // 实例地址，包含ip、port
  sentinelAddr *addr;
  // ...
} sentinelRedisInstance;
```

Sentinel状态初始化时，会根据配置文件对masters属性初始化。对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向其的异步网络：

- 命令连接：向主服务器发送命令，并接收回复。
- 订阅连接：用于订阅主服务器的`_sentinel_:hello`频道（防止消息丢失）。

#### 获取主服务器信息

Sentinel默认会以10秒一次的频率通过命令连接向主服务器发送`INFO`命令，以获取主服务器当前的信息（主要是服务器本身的信息，包括run_id，role(角色)，以及slave信息），之后会更新`sentinelState`。

#### 获取从服务器信息

当Sentinel从master那里获取到新的从服务器时，不仅会为其创建`sentinelRedisInstance`结构，还会与之建立命令连接和订阅连接。之后默认每十秒钟通过命令连接向从服务器发送`INFO`命令，获取其当前信息（run_id、role、master_host、master_port、主从连接状态、优先级、复制偏移量等），根据这些信息对相应实例结构进行更新。

#### 与sentinel通信

Sentinel会以每2秒一次的频率向订阅的`_sentinel_:hello`频道中发布sentinel自身的ip、端口号、runid、当前纪元，以及所监视的主服务器的ip、端口号、runid、当前纪元。

对于监视同一个服务器的多个sentinel来说，一个sentinel发送的信息会被其他sentinel所接收到，这些信息用于更新其他sentinel对发送信息的sentinel和监视的master的认知。

Sentinel感知到其他Sentinel的存在后就会与其相互建立命令连接。

#### 故障转移

- 主观下线

  默认情况下，Sentinel会以1秒一次的频率向所有与其建立命令连接的服务器（sentinel、master、slave）发送`PING`命令，并通过返回值判断实例是否在线。当在配置的`down_after_millisecond`时间内实例一直返回无效数据时，Sentinel便会修改实例对应的`sentinelRedisInstance`结构，将其标记为主观下线状态。

- 客观下线

  当Sentine将一个主服务器判断为主观下线后，会向其他监视这个主服务器的Sentinel进行询问，看它们是否也认为这个主服务器已经下线。当至少`quorum`（配置选项）个sentinel认为主服务器下线后，Sentinel就会将主服务器判断为客观下线状态，并对其进行故障转移。

- 选举领头Sentinel（raft算法）

  当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出领头Sentinel，由其进行故障转移。

  - 所有在线的Sentine都有被选举为领头的资格。
  - 每轮选举，epoch(纪元)加1。
  - 每个发现主服务器进入客观下线状态的Sentinel都会要求其他Sentinel为它投票。
  - 在一个纪元里面，每个Sentinel只能为一个Sentinel投票，并且是先到先得。
  - 某个Sentinel获得了半数以上的票，就会成为领头。
  - 如果在给定时间内，没有选举出领头，则在一段时间后进行下一轮选举，直至选举出领头。

- 故障转移

  领头Sentinel会针对已下线的主服务器执行故障转移。

  - 在主服务器所属的从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送`SLAVEOF no one`命令，将从服务器转换为主服务器。
  - 让其他从服务器改为复制新的主服务器。
  - 将已下线的主服务器设置为复制新出服务器，在其重新上线后就会成为新主服务器的从服务器。

### Redis Cluster

Redis Cluster是redis提供的分布式数据库方案，通过分片进行数据共享，并提供复制和故障转移功能。

Redis Cluster通常由多个节点组成，刚开始节点都是独立的，所以要组建一个集群，我们需要把多个独立的节点连接起来，构成一个包含多个节点的集群。

#### 集群数据结构

``` c
struct clusterNode {
  // ...
  // 节点的名字
  char name[REDIS_CLUSTER_NAMELEN];
  // 节点标识(主/从/在线/下线)
  int flag;
  // 配置纪元
  uint64_t configEpoch;
  char ip[REDIS_IP_STR_LEN];
  int port;
  // 保存连接节点所需的有关信息
  clusterLink *link;
  // 保存节点处理的槽(类似位图)
  unsigned char slots[16384/8];
  // 节点处理的槽的个数
  int numslots;
  // ...
};

typedef struct clusterLink {
  // ...
  // TCP套接字描述符
  int fd;
  // 输出缓冲区，保存着等待发送给其他节点的消息
  sds snduf;
  // 输入缓冲区，保存着从其他节点接收到的消息
  sds rcvbuf;
  // 与这个连接相关联的节点，没有就位NULL
  struct clusterNode *node;
} clusterLink;

// 每个节点都保存着一个clusterState结构，记录了当前节点的视角下，集群的状态
typedef struct clusterState {
  clusterNode *myself;
  // 当前纪元
  uint64_t currentEpoch;
  // 在线还是下线
  int state;
  // 集群中至少处理一个槽的节点的数量
  int size;
  // 集群节点名单，键为节点名字，值为对应clusterNode结构
  dict *nodes;
  // 槽的指派信息，指向指派给的节点的clusterNode结构的指针，为NULL表示未指派
  clusterNode *slots[16384];
  // 用跳跃表保存槽和键之间的关系
  zskiplist *slots_to_keys;
} clusterState;
```

节点通过握手来确定彼此的存在，并为将来的进一步通信打好基础。

#### 槽指派

Redis集群通过分片的方式来保存数据库中的键值对：整个数据库被分为16384个槽，每个集群可以处理0-16384个槽。当数据库中16384个槽都有节点在处理时，集群处于上线状态，否则处于下线状态。

通过向节点发送`CLUSTER ADDSLOTS`命令，可以将一个或多个槽指派给节点负责。clusterNode结构中用`slots`属性和`numslot`属性记录了节点负责处理的槽。因为取出和设置`slots`数组中的任意一个二进制位的复杂度仅为O(1)，所以检查节点是否处理某个槽和指派某个节点处理某个槽的复杂度都为O(1)。

节点除了将自己负责的槽记录下来外，还会向其他节点发送自己的slots数组，告知其他节点自己目前负责的槽。其他节点接收到消息后，会更新自己的clusterState结构中的slots数组。`clusterState`结构中的`slots`与`clusterNode`中的`slots`数组不同，它记录了所有槽的指派信息，因此每个节点都知道数据库中16384个槽的指派信息。

#### 在集群中执行命令

当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的键属于哪个槽，并检查这个槽是否指派给了自己：

- 指派给了自己：直接执行命令
- 没有指派给自己：向客户端返回一个MOVED错误，并指引客户端转向正确的节点，并再发送一次命令。一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是换一个套接字来发送命令。集群模式的`redis-cli`客户端接收到MOVED错误时，不会打印错误，而是自动进行节点转向，并打印出转向信息；而单机模式的`redis-cli`客户端的MOVED错误就会被打印出来，因为它不清楚MOVED的作用。

计算key属于哪个槽：`CRC16(key) & 16384`

在`clusterState`结构中，用跳跃表保存了槽和键之间的关系，跳跃表中每个节点的分值为槽号，节点的成员为一个数据库键。可以用来对某个或某些槽的数据库键做批量操作。

#### 重新分片

Redis集群可以将任意数量已指派的槽改为指派给另一个节点，并且所属的键值对也会被移动到目标节点。重新分片操作可以在线处理，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。

如果节点A正在迁移槽i至节点B，那么当节点A找不到客户端命令指定的键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找。

#### 故障转移

Redis集群中的节点也可分为master和slave，master用于处理槽，而从节点用于复制主节点，并且在主节点下线后选出一个替代主节点继续处理命令请求。

Redis集群中的每个节点都会定期向其他节点发送`PING`命令，检测对方是否在线。当在规定时间内没有返回`PONG`消息时，当前节点会认为对方疑似下线，之后会和其他主节点进行通信，询问它们是否认为该节点下线，当超过半数节点认为该节点下线时，将这个主节点标记为已下线，并对所有节点进行广播。

之后便进行故障转移，过程和Sentinel故障转移类似。



### 参考资料

《redis设计与实现第二版》